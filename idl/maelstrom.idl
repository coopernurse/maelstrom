
// maelstrom.idl: Interface definition for
// https://maelstromapp.com/

// Generic error codes:
//
// * 1001 - Invalid value (one or more fields has an invalid value)
// * 1002 - Already exists (uniqueness constraint violated)
// * 1003 - Not found (entity with provided ID was not found)
// * 1004 - Concurrent write violation (previous version of entity is not current)
//

interface MaelstromService {

    // PutProject registers a set of components and event sources, grouped under a single name
    // This call diffs the input project with the prior state of the project, updating components
    // in the project that already exist, adding components that do not, and removing components
    // associated with the project name that are no longer present in the input project.
    //
    // Validation is performed before any state changes are made. If invalid input is detected
    // no changes to the system will occur.
    //
    // Error Codes:
    //
    // * 1001 - input.name is invalid
    // * 1001 - input.components is empty
    // * 1001 - input.components contains an invalid component or event source
    //
    PutProject(input PutProjectInput) PutProjectOutput

    GetProject(input GetProjectInput) GetProjectOutput

    RemoveProject(input RemoveProjectInput) RemoveProjectOutput

    // PutComponent registers a component definition
    //
    // Error Codes:
    //
    // * 1001 - input.name is invalid
    // * 1004 - input.previousVersion does not match the version in the database
    //
    PutComponent(input PutComponentInput) PutComponentOutput

    // GetComponent returns a component with the given name
    //
    // Error Codes:
    //
    // * 1003 - No component found with that name
    //
    GetComponent(input GetComponentInput) GetComponentOutput

    // RemoveComponent deletes a component with the given name
    //
    // If no component is found with that name no error is raised
    // and the call silently no-ops.
    //
    // Error Codes:
    //
    // * 1001 - input.name is invalid
    //
    RemoveComponent(input RemoveComponentInput) RemoveComponentOutput

    // ListComponents returns a paginated list of components registered in the system
    // optionally filtered by name prefix.
    //
    // If no components exist in the system, ListComponentsOutput.components
    // will be an empty list.
    //
    // Results are sorted by name (ascending)
    //
    ListComponents(input ListComponentsInput) ListComponentsOutput


    // PutEventSource registers an event source definition associated
    // with a component
    //
    // Error Codes:
    //
    // * 1001 - input.name is invalid
    // * 1001 - input.componentName is invalid
    // * 1001 - No event source sub-type is provided
    // * 1001 - input.http is provided but has no hostname or pathPrefix
    // * 1003 - input.componentName does not reference a component defined in the system
    // * 1004 - input.previousVersion does not match the version in the database
    //
    PutEventSource(input PutEventSourceInput) PutEventSourceOutput

    // GetEventSource returns an event source with the given name
    //
    // Error Codes:
    //
    // * 1003 - No event source found with that name
    //
    GetEventSource(input GetEventSourceInput) GetEventSourceOutput

    // RemoveComponent deletes a component with the given name
    //
    // If no component is found with that name no error is raised
    // and the call silently no-ops.
    //
    // Error Codes:
    //
    // * 1001 - input.name is invalid
    //
    RemoveEventSource(input RemoveEventSourceInput) RemoveEventSourceOutput

    // ListEventSources returns a paginated list of event sources registered in the system
    // optionally filtered by name prefix, component name, or type.
    //
    // If no event sources exist in the system, ListEventSourcesOutput.eventSources
    // will be an empty list.
    //
    // Results are sorted by name (ascending)
    //
    ListEventSources(input ListEventSourcesInput) ListEventSourcesOutput

    // ListNodeStatus returns a paginated list of nodes registered in the system.
    //
    // If no nodes exist in the system, ListNodeStatusOutput.nodes
    // will be an empty list.
    //
    // Results are sorted by nodeId (ascending)
    //
    ListNodeStatus(input ListNodeStatusInput) ListNodeStatusOutput
}

interface NodeService {

    GetStatus(input GetNodeStatusInput) GetNodeStatusOutput

    StatusChanged(input StatusChangedInput) StatusChangedOutput

    // Error Codes:
    //
    // * 1003 - input.componentName does not reference a component defined in the system
    PlaceComponent(input PlaceComponentInput) PlaceComponentOutput

    StartStopComponents(input StartStopComponentsInput) StartStopComponentsOutput

}

struct Project {
    // Name of project. (a-zA-Z0-9_-)+
    // Name max size is 20 characters
    name         string
    components   []ComponentWithEventSources
}

struct ComponentWithEventSources {
    component     Component
    eventSources  []EventSource
}

struct Component {
    // Name of the component (a-zA-Z0-9_-)+
    // Name max size is 60 characters
    // This value uniquely identifies the component in the system.
    name         string

    // If the component is the member of a project, this is the project name
    projectName  string    [optional]

    // Environment variables - these override variables defined at the
    // project level (if applicable)
    environment  []NameValue

    // Minimum instances of this component to run (default=0)
    minInstances int      [optional]

    // Maximum instances of this component to run (default=0, no upper limit)
    maxInstances int      [optional]

    // Maximum concurrent requests to proxy to a single instance of this component
    maxConcurrency      int

    // If the % of maxConcurrency of all instances of this component exceeds this value,
    // more instances of the component will be started (respecting maxInstances if > 0).
    // Value should be 0..1 (e.g. .5 = 50%). (default=0.75)
    scaleUpConcurrencyPct      float   [optional]

    // If the % of maxConcurrency of all instances of this component is lower than this value,
    // instances of the component will be stopped (respecting minInstances if > 0).
    // Value should be 0..1 (e.g. .5 = 50%). (default=0.25)
    scaleDownConcurrencyPct    float   [optional]

    // Maximum request duration (in seconds)
    // Default = 60
    maxDurationSeconds  int   [optional]

    // Current version of the component
    // If the current version in the db does not match, a 1004 error is raised.
    // When creating a new component, set this to zero.
    version      int

    // Date component was last saved - may be omitted on put calls
    modifiedAt   int              [optional]

    docker       DockerComponent  [optional]
}

struct DockerComponent {
    image                   string
    command                 []string     [optional]
    httpPort                int
    httpHealthCheckPath     string

    // max seconds between container start and initial health check pass
    // if health check does not pass within this number of seconds, the container is stopped
    // if this value < 0 then no initial health check will be run at startup (default=60)
    httpStartHealthCheckSeconds  int     [optional]

    // interval to run health check (default=10)
    httpHealthCheckSeconds       int     [optional]

    // If component is not invoked within this duration then
    // the docker container is stopped and removed.  (default=300)
    idleTimeoutSeconds           int     [optional]

    // List of filesystem mounts to bind to container
    // Use we care, as you must ensure these paths exist on any host in the maelstrom cluster
    volumes                  []VolumeMount  [optional]

    // network name to bind container to - useful if using docker compose
    // locally with non-maelstrom resources (e.g. a database server) and you
    // wish to address those resources by name on the docker overlay network
    networkName              string         [optional]

    // Docker logging driver to use
    // See: https://docs.docker.com/config/containers/logging/configure/
    logDriver                string         [optional]

    // Options to pass to the logging driver.  Names are the same as the
    // keys specified in the docker documentation. For example "syslog-address"
    // or "fluentd-buffer-limit"
    logDriverOptions         []NameValue    [optional]

    limitCpu                 float          [optional]

    // RAM in MiB that should be reserved on a node when starting this component
    // Optional. Default=128
    reserveMemoryMiB         int            [optional]

    // Hard RAM limit for this component. This must be greater than or equal to reserveMemoryMiB
    // Optional. If not set, this will default to reserveMemoryMiB
    limitMemoryMiB           int            [optional]
}

struct VolumeMount {
    // See: https://godoc.org/github.com/docker/docker/api/types/mount#Type
    // default=bind
    type          string  [optional]

    // Path to mount point on host
    source        string

    // Path to mount inside container
    target        string

    // default=false
    readOnly      bool    [optional]
}

struct EventSource {
    // Name of the event source (a-zA-Z0-9_-)+
    // Name max size is 60 characters
    // This value uniquely identifies the event source in the system.
    name string

    // Name of the component the event source activates (a-zA-Z0-9_-)+
    // Name max size is 60 characters
    componentName string

    // If the component the event source is associated with is the member of a project,
    // this is the project name
    projectName  string    [optional]

    version      int
    modifiedAt   int

    // One and only one event source type may be provided
    http       HttpEventSource   [optional]
    cron       CronEventSource   [optional]
    sqs        SqsEventSource    [optional]
}

struct HttpEventSource {
    // at least one field (hostname, pathPrefix) must be provided
    // if more than one is provided, only requests matching all fields will match
    hostname      string    [optional]
    pathPrefix    string    [optional]
}

struct CronEventSource {
    // UNIX-like cron expression specifying when rule should fire
    // For format rules see: https://godoc.org/github.com/robfig/cron
    schedule      string

    // Request to mak
    http          CronHttpRequest
}

struct CronHttpRequest {
    // HTTP method: GET, POST, PUT, DELETE
    method        string

    // Request path, optionally including a query string
    // If a query string is included, make sure the parameters are
    // properly URL encoded as it will be used verbatim
    path          string

    // Request body (for POST, PUT)
    data          string       [optional]

    // HTTP headers
    headers       []NameValue  [optional]
}

struct SqsEventSource {
    // Name prefix of queues related to this event source
    // If more than one queue is found, the names will be sorted
    // and drained in ascending order. This allows priority queueing
    // to be done.  For example, create queues named:
    //     myQueue-0, myQueue-1, myQueue-2
    // In this example myQueue-0 would have highest priority and
    // would be drained before processing messages from myQueue-1
    queueNamePrefix       string

    // Request path, optionally including a query string
    // If a query string is included, make sure the parameters are
    // properly URL encoded as it will be used verbatim
    path                  string

    // Total max concurrent messages to process for this component (default=10)
    maxConcurrency        int     [optional]

    // Messages to receive per polling attempt (default=1)
    // Valid values: 1..10
    messagesPerPoll       int     [optional]

    // Concurrent messages to process per polling process
    // If you want strict FIFO processing, set this value to 1 and make sure
    // all SQS queues are created as FIFO queues and that producers are setting
    // MessageGroupId appropriately. This defaults to the messagesPerPoll value.
    concurrencyPerPoller  int     [optional]

    // Max seconds to mark message invisible before it is eligible
    // to dequeue again.  (default=300)
    // Messages successfully processed before this time elapses will
    // be deleted from the queue automatically.
    visibilityTimeout     int     [optional]

}

enum EventSourceType {
    http
    cron
    sqs
}

struct NodeStatus {
    nodeId             string
    startedAt          int
    observedAt         int
    version            int
    peerUrl            string
    totalMemoryMiB     int
    freeMemoryMiB      int
    numCPUs            int
    loadAvg1m          float
    loadAvg5m          float
    loadAvg15m         float
    runningComponents  []ComponentInfo
}

struct ComponentInfo {
    componentName      string
    maxConcurrency     int
    memoryReservedMiB  int
    lastRequestTime    int
    totalRequests      int
    activity           []ComponentActivity
}

struct ComponentActivity {
    requests      int
    concurrency   float
}

struct PutProjectInput {
    project   Project
}

struct PutProjectOutput {
    name                 string
    componentsAdded      []Component
    componentsUpdated    []Component
    componentsRemoved    []string
    eventSourcesAdded    []EventSource
    eventSourcesUpdated  []EventSource
    eventSourcesRemoved  []string
}

struct GetProjectInput {
    name    string
}

struct GetProjectOutput {
    project     Project
}

struct RemoveProjectInput {
    // name of project to remove - will remove related components and event sources
    name    string
}

struct RemoveProjectOutput {
    name    string

    // if project was found in the system this is true, otherwise false
    found   bool
}

struct RemoveComponentInput {
    // name of component to remove
    name    string
}

struct RemoveComponentOutput {
    name    string

    // if component was found in the system this is true, otherwise false
    found   bool
}

struct ListComponentsInput {
    // If specified only components matching this name prefix will be returned.
    namePrefix  string  [optional]

    // If specified only components matching this project name will be returned
    projectName      string            [optional]

    // Max items to return per response (1..1000)
    // default=1000
    limit       int     [optional]

    // If set the next set of paginated results will be returned
    nextToken   string  [optional]
}

struct ListComponentsOutput {
    // Components in current page of output or an empty list if
    // no additional results exist
    components    []Component

    // If set there are additional results.
    // Client may make another ListComponents() request setting this
    // as ListComponentsInput.nextToken
    nextToken   string  [optional]
}

struct GetComponentInput {
    name       string
}

struct GetComponentOutput {
    component     Component
}

struct PutComponentInput {
    // Component to save, keyed off component.name
    // component.version should be set to zero when creating a new component
    component Component
}

struct PutComponentOutput {
    // Name of the component stored
    name string

    // New (current) version of the component
    // For a newly created component, this value will be 1.
    // The value will increment by one with each successful PutComponent() call.
    version int
}

struct PutEventSourceInput {
    // EventSource to save, keyed off eventSource.name
    eventSource     EventSource
}

struct PutEventSourceOutput {
    // Name of the event source stored
    name string

    // New (current) version of the event source
    // For a newly created event source, this value will be 1.
    // The value will increment by one with each successful PutEventSource() call.
    version int
}

struct GetEventSourceInput {
    name    string
}

struct GetEventSourceOutput {
    eventSource     EventSource
}

struct RemoveEventSourceInput {
    // name of event source to remove
    name    string
}

struct RemoveEventSourceOutput {
    name    string

    // if event source was found in the system this is true, otherwise false
    found   bool
}

struct ListEventSourcesInput {
    // If specified only event sources matching this name prefix will be returned.
    namePrefix       string            [optional]

    // If specified only event sources matching this component name will be returned
    componentName    string            [optional]

    // If specified only event sources belonging to components with this project name will be returned
    projectName      string            [optional]

    // If specified only event sources matching this type will be returned
    eventSourceType  EventSourceType   [optional]

    // Max items to return per response (1..1000)
    // default=1000
    limit            int     [optional]

    // If set the next set of paginated results will be returned
    nextToken        string  [optional]
}

struct ListEventSourcesOutput {
    // Event sources in current page of output or an empty list if
    // no additional results exist
    eventSources    []EventSource

    // If set there are additional results.
    // Client may make another ListEventSources() request setting this
    // as ListEventSourcesInput.nextToken
    nextToken   string  [optional]
}

struct ListNodeStatusInput {
    // Max items to return per response (1..1000)
    // default=1000
    limit       int     [optional]

    // If set the next set of paginated results will be returned
    nextToken   string  [optional]
}

struct ListNodeStatusOutput {
    // Components in current page of output or an empty list if
    // no additional results exist
    nodes    []NodeStatus

    // If set there are additional results.
    // Client may make another ListNodeStatus() request setting this
    // as ListNodeStatusInput.nextToken
    nextToken   string  [optional]
}

struct GetNodeStatusInput {
    // status of the calling node.
    // clients that do not wish to share their state (or non-peer clients) may omit this.
    status           NodeStatus        [optional]
}

struct GetNodeStatusOutput {
    // status of the responding node
    status           NodeStatus
}

struct StatusChangedInput {
    nodeId      string
    exiting     bool
    status      NodeStatus   [optional]
}

struct StatusChangedOutput {
    nodeId      string
}

struct PlaceComponentInput {
    componentName     string
}

struct PlaceComponentOutput {
    componentName     string
    node              NodeStatus
}

struct StartStopComponentsInput {
    // Id of node making this request
    clientNodeId        string

    // NodeStatus.version that the client thinks the target is currently on
    // If the target's version differs, that suggests a concurrent modification of the target,
    // and this operation will be rejected by the target.
    // This allows multiple nodes to optimistically attempt to schedule concurrent scaling operations
    // without central coordination.
    targetVersion       int

    // Number of instances of each component the client would like the target
    // node to add (delta > 0) or remove (delta < 0).
    targetCounts        []ComponentDelta

    // If true, targetStatus will be populated after performing changes
    // Optional. default=false
    returnStatus        bool     [optional]
}

struct StartStopComponentsOutput {
    // If targetVersion did not match current version, this struct will be returned
    // so that client can adjust its state and potentially try again
    // If this is true, started, stopped, and errors will all be empty.
    targetVersionMismatch    bool

    // This is populated if targetVersionMismatch=true, or if returnStatus=true
    targetStatus             NodeStatus  [optional]

    // components started, or empty list if no containers started
    started          []ComponentDelta

    // components stopped, or empty list if no containers stopped
    stopped          []ComponentDelta

    // ComponentCount messages that resulted in errors are included here, or empty list if no errors
    errors           []ComponentDeltaError
}

struct ComponentDelta {
    componentName     string
    delta             int
    requiredMemoryMiB int
}

struct ComponentDeltaError {
    componentDelta    ComponentDelta
    error             string
}

struct NameValue {
    name   string
    value  string
}